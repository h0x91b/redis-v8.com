{% extends 'layout.html' %}

{% block content %}
					<div class="page-header">
						<h1>Quick start</h1>
					</div>
					<p class="description">
						This tutorial is targeted at those who are already familiar with redis, as well as a basic knowledge of JS and want to quickly get to the core of redis-v8. If you are not familiar with redis, you should start with <a href="http://redis.io/topics/twitter-clone">this lesson</a>, more lessons can be found <a href="http://redis.io/documentation">here</a>.
					</p>
					<p>
						Redis wonderful, comfortable and incredibly fast database, but redis have a few problems. 
						<ol>
							<li>Many small network packets. Even the use of pipelining can not always help, because it is not everywhere possible to use.</li>
							<li>Very hard to trace the connection between the keys, the keys are many and as the size of the project is becoming more and more difficult to track who is who.</li>
						</ol>
						Redis-v8 solves both of these problems and as a bonus gives a very solid performance boost!
					</p>
					<div class="page-header">
						<h3>For this tutorial, you will need:</h3>
					</div>
					<ol>
						<li>
							<a href="/downloads/">
								Redis-V8 <i class="icon-download-alt"></i>
							</a>
						</li>
						<li>
							<a href="http://www.php.net/downloads.php" target="_blank">
								PHP <i class="icon-download-alt"></i></a>
							</li>
						<li>
							<a href="https://github.com/h0x91b/redis-v8/raw/master/Client-Libraries/PHP/predis-0.8.3.zip" target="_blank">
								Predis <i class="icon-download-alt"></i></a> or any other redis client for PHP
							</li>
						<li>15 minutes of free time</li>
					</ol>
					<div class="page-header">
						<h3>redis-v8 + PHP</h3>
					</div>
					<dl>
						<dt>Compile and run redis-server</dt>
						<dd>
							In order to compile and run redis-v8 you need to perform the following commands:
							<pre class="prettyprint linenums">
git clone git://github.com/h0x91b/redis-v8.git
cd redis-v8/redis/
make
cd src/
./redis-server ../redis.conf
</pre>
						</dd>
						<dt>Hello world by php + redis-v8</dt>
						<dd>
							Once the server is running, we can start writing the code for that, create an index.php file and write in it:
								<pre class="prettyprint linenums languague-php">
&lt;?php
//load the library predis
require 'Predis/Autoloader.php';
Predis\Autoloader::register();
//Create a connection (the default 127.0.0.1:6379)
$redis = new Predis\Client();
//JS command will execute javascript inside a database
//In JS is an object redis, on which are all functions of the database, set, get, incr etc ...
//Let`s make a key "hello", with a value "world" and return it to the PHP
var_dump( 
	$redis->js(
		'redis.set("hello","world"); return redis.get("hello");'
	) 
);
?&gt;</pre>
							The output of the script will be like this:
							<pre class="prettyprint linenums languague-php">
array(2) {
  ["ret"]=>
  string(5) "world"
  ["cmds"]=>
  int(2)
}</pre>
								redis-v8 when you use the JS or JSCALL always returns JSON here is this kind of 
								<pre class="prettyprint linenums languague-js">{ret:<answer>,cmds:<the number of commands to the database>}</pre>
								<div class="mini_dl">
									<dl>
										<dt><dfn>ret</dfn></dt>
										<dd>It is the value returned by the called function.</dd>
									</dl>
									<dl class="mini_dl">
										<dt><dfn>cmds</dfn></dt>
										<dd>indicates the number of commands executed in a database in Example was performed 2 commands (one set and one get)</dd>
									</dl>
								</div>
								<p><span class="label label-info">Info</span> For ease of use in PHP, modifed Library predis. Itself will convert the JSON into a standard PHP Array.</p>
							<div class="alert alert-info">
								Normal predis not aware of the availability of new commands (JS and JSCALL), so a modified version of predis you can download on the page <a href="/downloads/#predis">downloads</a>.
							</div>
						</dd>
						<dt>Now let's do something useful</dt>
						<dd>
							At the root of the downloaded redis-v8 there is a folder called "js", create a new file in it "post.js" and write in it:
							<pre class="prettyprint linenums languague-js">
//This function will write a comment to the database
function makeCommentForPost(postId, title, body, author){
	//Obtain the new unique ID for comment
	var commentId = redis.incr( 'INCR:COMMENT_ID' );
	//Create a JS object for comment
	var comment = {
		id: commentId,
		title: title,
		body: body,
		author: author
	};
	//Write the comment object to the database
	redis.hmset( 'HSET:COMMENT_FOR_POST:'+postId+':'+commentId, comment );
	//Add a comment to Ordered set, sorted by time
	redis.zadd( 'ZSET:COMMENTS_FOR_POST:'+postId, Math.floor(+new Date/1000), commentId );
	//Return the ID of a comment
	return commentId;
}
</pre>
							<p>
								And so, we have created a function makeCommentForPost in JS, this function will be available to us in command "JS" and "JSCALL". But in order to redis-v8 discovered the existence of a new function, you must upgrade the environment V8, it is enough to perform the command "JSRELOAD". Run this command we can by any client for redis, for example standard redis-cli:
								<pre class="prettyprint linenums">
cd redis-v8/redis/src/
./redis-cli JSRELOAD
</pre>
							</p>
							<p>
								<span class="label label-info">Info</span> redis-v8 will recursively load all js files from redis-v8/js/, ie You can always make a convenient folder tree. Location js folder itself can be changed in redis.conf by directive js-dir.
							</p>
						</dd>
						<dt>Use of function makeCommentForPost</dt>
						<dd>
							Now let's use a new function from the PHP. To do this, go back to our index.php and write:
							<pre class="prettyprint linenums languague-php">
&lt;?php
//load the library predis
require 'Predis/Autoloader.php';
Predis\Autoloader::register();
//Create a connection (the default 127.0.0.1:6379)
$redis = new Predis\Client();
var_dump( 
	$redis->jscall( //jscall allows you to call JS function and pass any arguments safely
		"makeCommentForPost", //the name of the called JS function
		1, //argument 1 (postId)
		"post title", //argument 2 (title)
		"post body", //argument 3 (body)
		"post author" //argument 4 (author)
	) 
);
?&gt;</pre>
							Return from JSCALL has exactly the same format as from JS:
							<pre class="prettyprint linenums languague-php">
array(2) {
  ["ret"]=>
  int(1)
  ["cmds"]=>
  int(3)
}</pre>
							<div class="mini_dl">
								<dl>
									<dt><dfn>ret</dfn></dt>
									<dd>this is the first comment, accordingly, its ID will be 1.</dd>
								</dl>
								<dl class="mini_dl">
									<dt><dfn>cmds</dfn></dt>
									<dd>3 because the function call was passed 3 commands to the database (incr, hmset and zadd).</dd>
								</dl>
							</div>
							<p>
								Execute the script a couple of times to populate the database.
							</p>
						</dd>
						<dt>Make a function that will bring back all comments</dt>
						<dd>
							Open your js/post.js and appends in it:
							<pre class="prettyprint linenums languague-js">
function getCommentsForPost(postId){
	//Get the list IDs of comments in descending order, newest first.
	var comment_ids = redis.zrevrange('ZSET:COMMENTS_FOR_POST:'+postId,0,-1);
	
	var comments = comment_ids.map(function(commentId){
		//We take out the comment itself
		var comment = redis.hgetall('HSET:COMMENT_FOR_POST:'+postId+':'+commentId);
		//Find out post time of comment
		comment.timestamp = redis.zscore('ZSET:COMMENTS_FOR_POST:'+postId,commentId);
		//Add to the list
		return comment;
	});
	//Return list
	return comments;
}
</pre>
							Do not forget to update your environment v8 with JSRELOAD :). Open your index.php file and appends:
							<pre class="prettyprint linenums languague-php">
var_dump( $redis->jscall("getCommentsForPost",1) );
</pre>
							Run our index.php and get a whole list of comments:
							<pre class="prettyprint linenums languague-php">
array(2) {
  ["ret"]=>
  array(4) {
    [0]=>
    array(5) {
      ["id"]=>
      string(1) "4"
      ["title"]=>
      string(10) "post title"
      ["body"]=>
      string(9) "post body"
      ["author"]=>
      string(11) "post author"
      ["timestamp"]=>
      string(13) "1369063795714"
    }
    [1]=>
    array(5) {
		...
    }
	...
  }
  ["cmds"]=>
  int(9)
}</pre>
							<p>
								As you can see, with a single command from php to redis-v8 we actually did 9 commands to redis and got a formatted list of comments in one package. This is the "ready" list of comments that can now be directly in this form pass to the template.
							</p>
						</dd>
						<dt>Debugging</dt>
						<dd>
							Debugging can be done using the built-in object console, the result of the call will be recorded in redis.log. (See a <a href="/docs/#jsapi">redis-v8 API</a> for details)
							<pre class="prettyprint">
cd redis-v8/redis/src
./redis-cli
JS "console.log('return of redis.get is',redis.get('hello'))"</pre>
							<p>
								In the terminal is running redis-server appears this entry:
								
								<pre class="prettyprint">
[2326] 22 May 02:01:51.171 * console.log argument[0] = return of redis.get is
[2326] 22 May 02:01:51.171 * console.log argument[1] = world</pre>
							</p>
						</dd>
						<dt>The final pseudo example clearly demonstrates the power of the redis-v8</dt>
						<dd>
							Let's say we have a page in the blog and we want to get everything you need to render a template:
							<pre class="prettyprint linenums languague-js">
function getPost(alias){
	//getPostByAlias will return the post itself
	//Will find post by its alias, make the necessary increment of views, etc ...
	var post = getPostByAlias(alias);
	var postId = post.id;
	
	//This function will run through the lists of related posts and also bring them back to us
	post.relatedPosts = relatedPosts(postId);
	
	//Load the required number of comments
	//Let's say 100 comments from the first page
	post.comments = commentsForPost(postId,1,100);
	
	//Load all the tags of the post to build a beautiful tag cloud.
	post.tags = tagsForPost(postId);
	
	//Load the data on the category of the post, this is also likely need on the page
	post.category = getCategory(post.category);
	
	//We find the author, his karma, Avatars, etc.
	post.author = getAuthor(postId);
	
	//Take a list of recent articles by this author.
	post.author.last_articles = lastArticlesByAuthor(post.author.id);
	
	//And return A WHOLE object that can be simply passed to the template.
	return post;
}
</pre>
						</dd>
						<dt>Conclusion</dt>
						<dd>
							<p>
								JS function in the redis-v8 not only save bandwidth and the number of packets, but also can fully replace the standard procedure in the Model MVC (Model-View-Controller). And since all the commands to the database occur directly in the database itself, the performance grows from 2 to 50 times (more on the page <a href="/benchmarks/">benchmarks</a>)
							</p>
							<p>
								The second advantage is that the JS scripts usually are small and there are always very easy to trace all the keys, even on a very large project.
							</p>
						</dd>
						<dt>Now what?</dt>
						<dd>
							<ul>
								<li><a href="/docs/#jsapi">API Docs of redis-v8</a></li>
								<li><a href="/downloads/">Downloads of redis-v8</a></li>
								<!--<li><a href="#">Продвинутый урок "Делаем свой блог на redis-v8"</a></li>-->
								<!--<li><a href="#">Оптимизация и debugging redis-v8</a></li>-->
								<!-- <li><a href="/roadmap/">Road map проекта redis-v8</a></li> -->
							</ul>
						</dd>
					</dl>
					
{% endblock %}